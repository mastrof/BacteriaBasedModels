var documenterSearchIndex = {"docs":
[{"location":"checks/#Validation","page":"Validation","title":"Validation","text":"","category":"section"},{"location":"checks/","page":"Validation","title":"Validation","text":"It's important to check that our microbes behave as expected. In this section, we compare various Bactos.jl functionalities against theoretical results from the literature. If some functionality lacks validation please open an issue.","category":"page"},{"location":"checks/#Velocity-autocorrelation-functions","page":"Validation","title":"Velocity autocorrelation functions","text":"","category":"section"},{"location":"checks/","page":"Validation","title":"Validation","text":"The velocity autocorrelation functions for different swimming patterns have been evaluated analytically by Taktikos et al. (2013)<sup>1</sup>.","category":"page"},{"location":"checks/","page":"Validation","title":"Validation","text":"First, we will set identical parameters for all the swimmers. For RunReverse and RunReverseFlick we will assume that the properties in the forward and backward mode are identical.","category":"page"},{"location":"checks/","page":"Validation","title":"Validation","text":"U = 30.0 # swimming speed in μm/s\nτ_run = 1.0 # average unbiased run time in s\nω = 1 / τ_run # average unbiased turn rate in 1/s\nΔt = 0.01 # integration timestep in s\nextent = 1e4 # domain size in μm","category":"page"},{"location":"checks/","page":"Validation","title":"Validation","text":"We initialise three distinct populations, differing only in their motility, merge them all into a single population and initialise our model","category":"page"},{"location":"checks/","page":"Validation","title":"Validation","text":"n = 200 # number of microbes in each population\nmicrobes_runtumble = [\n    Microbe{3}(id=i,\n        turn_rate=ω, motility=RunTumble(speed=[U])\n    )\n    for i in 1:n\n]\nmicrobes_runrev = [\n    Microbe{3}(id=n+i,\n        turn_rate=ω, motility=RunReverse(speed_forward=[U])\n    )\n    for i in 1:n\n]\nmicrobes_runrevflick = [\n    Microbe{3}(id=2n+i,\n        turn_rate=ω, motility=RunReverseFlick(speed_forward=[U])\n    )\n    for i in 1:n\n]\n\nmicrobes = vcat(\n    microbes_runtumble, microbes_runrev, microbes_runrevflick\n)\n\nmodel = initialise_model(;\n    microbes,\n    extent, periodic = true,\n    timestep = Δt\n)","category":"page"},{"location":"checks/","page":"Validation","title":"Validation","text":"To evaluate the velocity autocorrelation functions, we only need to store the :vel field of the microbes during the simulation. To get a good statistics we need simulation times that are sufficiently longer than the average run length τ_run.","category":"page"},{"location":"checks/","page":"Validation","title":"Validation","text":"nsteps = round(Int, 100τ_run / Δt)\nadata = [:vel]\nadf, = run!(model, microbe_step!, nsteps; adata)","category":"page"},{"location":"checks/","page":"Validation","title":"Validation","text":"We can now separate the dataframes for the three subpopulations by their motility type and evaluate their velocity autocorrelation functions using the built-in autocorrelation function. For large amounts of data autocorrelation can take some time (O(t<sup>2</sup>n)).","category":"page"},{"location":"checks/","page":"Validation","title":"Validation","text":"adf_runtumble = filter(:id => id -> model.agents[id].motility isa RunTumble, adf)\nadf_runrev = filter(:id => id -> model.agents[id].motility isa RunReverse, adf)\nadf_runrevflick = filter(:id => id -> model.agents[id].motility isa RunReverseFlick, adf)\nadfs = [adf_runtumble, adf_runrev, adf_runrevflick]\n\nΦ = hcat([autocorrelation(a,:vel) for a in adfs]...)","category":"page"},{"location":"checks/","page":"Validation","title":"Validation","text":"The theoretical values (normalized) are given by Taktikos et al. (2013)<sup>1</sup>.","category":"page"},{"location":"checks/","page":"Validation","title":"Validation","text":"t = range(0, (nsteps-1)*Δt; step=Δt)\nΦ_theoretical = hcat([\n    exp.(-t ./ τ_run),\n    exp.(-t ./ (τ_run / 2)),\n    (1 .- t ./ (2τ_run)) .* exp.(-t ./ τ_run),\n]...)","category":"page"},{"location":"checks/","page":"Validation","title":"Validation","text":"Agreement between our simulation and theory is great.","category":"page"},{"location":"checks/","page":"Validation","title":"Validation","text":"plot(\n    xlims=(0,6τ_run), ylims=(-0.1, 1.05),\n    xlab=\"Δt / τ\",\n    ylab=\"velocity autocorrelation\",\n)\nplot!(t, Φ_theoretical, lw=2, lc=[1 2 3], label=[\"Run-Tumble\" \"Run-Reverse\" \"Run-Reverse-Flick\"])\n# slice simulation data for better visibility\nscatter!(t[1:15:end], Φ[1:15:end,:] ./ U^2, m=:x, mc=[1 2 3], label=false)\nhline!([0.0], lw=0.8, ls=:dash, lc=:black, lab=false)","category":"page"},{"location":"checks/","page":"Validation","title":"Validation","text":"(Image: Comparison between numerical and theoretical velocity autocorrelation functions for bacteria with different motile patterns)","category":"page"},{"location":"checks/#Mean-squared-displacement","page":"Validation","title":"Mean-squared displacement","text":"","category":"section"},{"location":"checks/","page":"Validation","title":"Validation","text":"It's also easy to evaluate the mean-squared displacement (MSD) of our microbes during a simulation. We will now run simulations of run-tumble bacteria using different reorientation distributions (parameterized by the average inclination angle θ), and compare the MSD as a function of θ to theoretical expectations using the well-known diffusivity formula by Lovely and Dahlquist (1975)<sup>2</sup>","category":"page"},{"location":"checks/","page":"Validation","title":"Validation","text":"D = dfracv^2tau3(1-alpha)","category":"page"},{"location":"checks/","page":"Validation","title":"Validation","text":"where alpha = left costheta right represents the directional persistence of the trajectory.","category":"page"},{"location":"checks/","page":"Validation","title":"Validation","text":"Since D only depends on left costheta right and not on the full P(theta) distribution, we will simply use degenerate distributions P_i(theta) = delta(theta-bartheta) for different values bartheta and compare the MSD estimated from our simulations to the theoretical expectation. Taktikos et al. (2013)<sup>1</sup> provide the analytical expression for the MSD which interpolates between the short-term ballistic regime and the long-term diffusive regime:","category":"page"},{"location":"checks/","page":"Validation","title":"Validation","text":"rm MSD(t) = 6Ddfractau1-alpha\nleft\n    dfrac(1-alpha)ttau-1+\n    rm expleft( -dfrac(1-alpha)ttau right)\nright","category":"page"},{"location":"checks/","page":"Validation","title":"Validation","text":"We will setup our systems as usual and then run each simulation independently","category":"page"},{"location":"checks/","page":"Validation","title":"Validation","text":"using Distributions: Uniform\nθs = [π/6, π/4, π/3, π/2, π]\n\nU = 30.0 # swimming speed in μm/s \nτ = 1.0 # average run time in s \nω = 1 / τ # average turn rate in 1/s\n\nnmicrobes = 200\nmicrobes = [\n    [\n        Microbe{3}(\n            id = n, turn_rate = ω,\n            motility = RunTumble(speed=[U], polar=[θ,-θ])\n        ) for n in 1:nmicrobes \n    ] for θ in θs\n]\n\ndt = 0.05 # s \nL = 500.0 # μm\nmodels = [\n    initialise_model(;\n        microbes = microbes[i],\n        timestep = dt, extent = L\n    ) for i in eachindex(microbes)\n]\n\nnsteps = round(Int, 100τ / dt)\nadata = [:pos]\nadfs = [run!(model, microbe_step!, nsteps; adata)[1] for model in models]","category":"page"},{"location":"checks/","page":"Validation","title":"Validation","text":"We can now evaluate the MSD for each population using the msd function; since the simulations were performed in a periodic domain, we will need to specify the size of the domain as a keyword argument","category":"page"},{"location":"checks/","page":"Validation","title":"Validation","text":"MSD = msd.(adfs; L=L)","category":"page"},{"location":"checks/","page":"Validation","title":"Validation","text":"We can now slice our experimental data and plot the results.","category":"page"},{"location":"checks/","page":"Validation","title":"Validation","text":"t = (1:nsteps).*dt\nlogslice = round.(Int, exp10.(range(0,3,length=10)))\nplot(\n    xlab = \"Δt / τ\",\n    ylab = \"MSD / (Uτ)²\",\n    legend = :bottomright, legendtitle = \"1-α\",\n    scale = :log10\n)\nscatter!(t[logslice]./τ, hcat(MSD...)[logslice,:]./(U*τ)^2,\n    m=:x, ms=6, msw=2, lab=false)\nfor i in eachindex(θs)\n    α = cos(θs[i])\n    T = τ / (1-α)\n    D = U^2*T / 3\n    dr² = @. 6*D*T * (t/T - 1 + exp(-t/T))\n    plot!(t./τ, dr²./(U*τ)^2, lab=round(1-α,digits=2), lc=i, lw=2)\nend # for\nplot!(xticks=exp10.(-1:2), yticks=exp10.(-2:2:2))","category":"page"},{"location":"checks/","page":"Validation","title":"Validation","text":"(Image: Mean-squared displacement of run-tumble bacteria with different reorientation distributions)","category":"page"},{"location":"checks/#References","page":"Validation","title":"References","text":"","category":"section"},{"location":"checks/","page":"Validation","title":"Validation","text":"Taktikos, J.; Stark, H.; Zaburdaev, V. How the Motility Pattern of Bacteria Affects Their Dispersal and Chemotaxis. PLoS ONE 2013, 8 (12), e81936. https://doi.org/10.1371/journal.pone.0081936.\nLovely, P.S.; Dahlquist, F.W. Statistical measures of bacterial motility and chemotaxis. Journal of Theoretical Biology 1975, 50 (2), 477-496. https://doi.org/10.1016/0022-5193(75)90094-6","category":"page"},{"location":"#Bactos.jl","page":"Home","title":"Bactos.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Agent-based modelling of bacterial motility and chemotaxis in Julia.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Built on Agents.jl\nBacterial motility in 1, 2 and 3 dimensions with customizable motile patterns.\nChemotaxis with different tunable models (Brown-Berg, Brumley, Celani, Xie).\nIntegration of differential equations in parallel with agent stepping via DifferentialEquations.jl, using finite differences.\nEasy evaluation of quantities of interest (mean-squared displacement, autocorrelation functions...).","category":"page"},{"location":"#Limitations","page":"Home","title":"Limitations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The length of the integration timestep also sets the sensing timescale in chemotaxis models (i.e. the time over which a microbe integrates environmental signals).\nReorientations are always assumed to be instantaneous.\nNo hydrodynamic interactions.","category":"page"},{"location":"#Future-directions","page":"Home","title":"Future directions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Swimming in flow fields.\nMore behavioral strategies (chemokinesis, infotaxis...).\nExtended set of core functionalities (encounters, interactions...).\nComplex environments (non-spherical obstacles).\nSteric interactions and non-spherical microbes.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use this package in work that leads to a publication, please cite the GitHub repository:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{Foffi2022,\n    author = {Foffi, R.},\n    title = {Bactos.jl},\n    year = {2022},\n    publisher = {GitHub},\n    journal = {GitHub repository},\n    howpublished = {\\url{https://github.com/mastrof/Bactos.jl}}\n}","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project has received funding from the European Union's Horizon 2020 research and innovation programme under the Marie Skłodowska-Curie grant agreement No 955910.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Ready-to-run scripts for the functionalities introduced here can be found in the examples directory of the repo.","category":"page"},{"location":"tutorial/#Creating-a-bacterium","page":"Tutorial","title":"Creating a bacterium","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Bacteria are represented by custom types, that must be subtypes of the AbstractAgent type implemented by Agents.jl.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"AbstractMicrobe","category":"page"},{"location":"tutorial/#Bactos.AbstractMicrobe","page":"Tutorial","title":"Bactos.AbstractMicrobe","text":"AbstractMicrobe{D} <: AbstractAgent where {D<:Integer}\nYourMicrobeType{D} <: AbstractMicrobe{D}\n\nAll microbe types in Bactos.jl simulations must be instances of user-defined types that are subtypes of AbstractMicrobe. The parameter D defines the dimensionality of the space in which the microbe type lives (1, 2 and 3 are currently supported).\n\nAll microbe types should have the following fields: - id::Int → id of the microbe - pos::NTuple{D,Float64} → position of the microbe - vel::NTuple{D,Float64} → velocity of the microbe - motility → motile pattern of the microbe - turn_rate::Float64 → average reorientation rate of the microbe - rotational_diffusivity::Float64 → rotational diffusion coefficient\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"By default, Bactos.jl provides a basic Microbe type, that is usually sufficient for the simplest types of simulations.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Microbe","category":"page"},{"location":"tutorial/#Bactos.Microbe","page":"Tutorial","title":"Bactos.Microbe","text":"Microbe{D} <: AbstractMicrobe{D}\n\nBasic microbe type for simple simulations.\n\nDefault parameters:\n\nid::Int → identifier used internally by Agents.jl\npos::NTuple{D,Float64} = ntuple(zero,D) → position\nmotility = RunTumble() → motile pattern\nvel::NTuple{D,Float64} = rand_vel(D) .* rand(motility.speed) → velocity vector\nturn_rate::Float64 = 1.0 → frequency of reorientations\nstate::Float64 → generic variable for a scalar internal state\nrotational_diffusivity::Float64 = 0.0 → rotational diffusion coefficient\nradius::Float64 = 0.0 → equivalent spherical radius of the microbe\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to create a Microbe living in a one-dimensional space we can just call","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Microbe{1}(id=0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It is required to pass a value to the id argument (this behavior might change in the future). All the other parameters will be given default values (as described in the type docstring) if not assigned explicitly.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly, for bacteria living in two or three dimensions we can use","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Microbe{2}(id=0)\nMicrobe{3}(id=0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Custom parameters can be set via kwargs:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Microbe{3}(\n    id = 0,\n    pos = (300.0, 0.0, 0.0),\n    motility = RunTumble(speed = Normal(40.0, 4.0)),\n    vel = rand_vel(3) .* 40.0,\n    turn_rate = 1.5,\n    state = 0.0,\n    rotational_diffusivity = 0.035,\n    radius = 0.5\n)","category":"page"},{"location":"tutorial/#Creating-a-model","page":"Tutorial","title":"Creating a model","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BacteriaBasedModel provides a fast way to initialise an AgentBasedModel (from Agents.jl) via the initialise_model function, using a typical procedure. If higher levels of customization are needed, the model will need to be created by hand.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"initialise_model","category":"page"},{"location":"tutorial/#Bactos.initialise_model","page":"Tutorial","title":"Bactos.initialise_model","text":"initialise_model(;\n    microbes,\n    timestep,\n    extent, spacing = extent/20, periodic = true,\n    random_positions = true,\n    model_properties = Dict(),\n    diffeq = false, ode_integrator = dummy_integrator\n)\n\nInitialise an AgentBasedModel from population microbes. Requires the integration timestep and the extent of the simulation box.\n\nWhen random_positions = true the positions assigned to microbes are ignored and new ones, extracted randomly in the simulation box, are assigned; if random_positions = false the original positions in microbes are kept.\n\nAny extra property can be assigned to the model via the model_properties dictionary.\n\nSet diffeq = true and provide an ode_integrator (e.g. through the initialise_ode function) to integrate a differential equation in parallel to microbe stepping.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now generate a population of microbes and, after choosing an integration timestep and a domain size, we initialise our model, placing the microbes at random locations in the domain.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"microbes = [Microbe{3}(id=i) for i in 1:10]\ntimestep = 0.1\nextent = 100.0\nmodel = initialise_model(;\n    microbes = microbes,\n    timestep = timestep,\n    extent = extent\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"AgentBasedModel with 10 agents of type Microbe\n space: periodic continuous space with (100.0, 100.0, 100.0) extent and spacing=5.0\n scheduler: fastest\n properties: timestep","category":"page"},{"location":"tutorial/#Random-walks","page":"Tutorial","title":"Random walks","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we can already generate random walks. The setup follows previous sections.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"timestep = 0.1\nextent = 1e6 # just a large value to stay away from boundaries\nnmicrobes = 8\n# initialise all microbes at same position\nmicrobes = [Microbe{1}(id=i, pos=(L/2,)) for i in 1:nmicrobes]\n\nmodel = initialise_model(;\n    microbes,\n    timestep,\n    extent, periodic = false,\n    random_positions = false\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we need to define the adata variable to choose what observables we want to track, throughout the simulation, for each agent in the system. In our case, only the position field","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"adata = [:pos]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we can run the simulation; the microbe_step! function will take care of the stepping and reorientations according to the properties of each microbe:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"nsteps = 1000\nadf, = run!(model, microbe_step!, nsteps; adata)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"x = first.(vectorize_adf_measurement(adf, :pos))'\nplot(\n    (0:nsteps).*dt, x,\n    legend = false,\n    xlab = \"time\",\n    ylab = \"position\"\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: One-dimensional random walks of 8 microbes starting from same position)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly for a two-dimensional random walk, using run-reverse-flick motility and non-zero rotational diffusion:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"dt = 0.1\nL = 1000.0\nnmicrobes = 1\nmicrobes = [\n    Microbe{2}(\n        id=i, pos=(L/2,L/2),\n        motility=RunReverseFlick(),\n        rotational_diffusivity = 0.2,\n        ) for i in 1:nmicrobes\n]\n\nmodel = initialise_model(;\n    microbes,\n    timestep = dt,\n    extent, periodic = false,\n    random_positions = false,\n)\n\nnsteps = 500\nadata = [:pos]\nadf, = run!(model, microbe_step!, nsteps; adata)\n\ntraj = vectorize_adf_measurement(adf, :pos)\nx = first.(traj)'\ny = last.(traj)'\nplot(\n    x, y, line_z = (0:nsteps).*dt,\n    legend=false,\n    xlab = \"x\", ylab = \"y\",\n    colorbar = true, colorbar_title = \"time\"\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Two-dimensional random walk using run-reverse-flick motility)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Microbes with different motile patterns can also be combined in the same simulation, without extra complications or computational costs:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"n = 3\nmicrobes_runtumble = [Microbe{2}(id=i, motility=RunTumble()) for i in 1:n]\nmicrobes_runrev = [Microbe{2}(id=n+i, motility=RunReverse()) for i in 1:n]\nmicrobes_runrevflick = [Microbe{2}(id=2n+1, motility=RunReverseFlick()) for i in 1:n]\nmicrobes = vcat(\n    microbes_runtumble, microbes_runrev, microbes_runrevflick\n)","category":"page"},{"location":"tutorial/#Chemotaxis-in-a-linear-gradient","page":"Tutorial","title":"Chemotaxis in a linear gradient","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We will now reproduce a classical chemotaxis assay: bacteria in a rectangular channel with a linear attractant gradient.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Bactos.jl requires three functions to be defined for the built-in chemotaxis models to work: concentration_field, concentration_gradient, and concentration_time_derivative; all three need to take the two arguments (pos, model). First we need to define our concentration field and its gradient (we don't define its time derivative since it will be held constant). We will use a linear gradient in the x direction. Here we can define also the gradient analytically, in more complex cases it can be evaluated numerically through the finite difference interface.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"concentration_field(x,y,C₀,∇C) = C₀ + ∇C*x\nfunction concentration_field(pos, model)\n    x, y = pos\n    C₀ = model.C₀\n    ∇C = model.∇C\n    concentration_field(x, y, C₀, ∇C)\nend\nconcentration_gradient(x,y,C₀,∇C) = [∇C, 0.0]\nfunction concentration_gradient(pos, model)\n    x, y = pos\n    C₀ = model.C₀\n    ∇C = model.∇C\n    concentration_gradient(x, y, C₀, ∇C)\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We choose the parameters, initialise the population (with two distinct chemotaxers) with all bacteria to the left of the channel, and setup the model providing the functions for our concentration field to the model_properties dictionary.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"timestep = 0.1 # s\nLx, Ly = 1000.0, 500.0 # μm\nextent = (Lx, Ly) # μm\nperiodic = false\n\nn = 50\nmicrobes_brumley = [\n    MicrobeBrumley{2}(id=i, pos=(0,rand()*Ly), chemotactic_precision=1)\n    for i in 1:n\n]\nmicrobes_brown = [\n    MicrobeBrownBerg{2}(id=n+i, pos=(0,rand()*Ly))\n    for i in 1:n\n]\nmicrobes = [microbes_brumley; microbes_brown]\n\nC₀ = 0.0 # μM\n∇C = 0.01 # μM/μm\nmodel_properties = Dict(\n    :concentration_field => concentration_field,\n    :concentration_gradient => concentration_gradient,\n    :concentration_time_derivative => (_,_) -> 0.0,\n    \n    :compound_diffusivity => 500.0, # μm²/s\n    :C₀ => C₀,\n    :∇C => ∇C,\n)\n\nmodel = initialise_model(;\n    microbes,\n    timestep,\n    extent, periodic,\n    model_properties,\n    random_positions = false\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Notice that we also defined an extra property compound_diffusivity. This quantity is required by the models of chemotaxis that use sensing noise (such as Brumley, XieNoisy, CelaniNoisy). 500 μm²/s is a typical value for small molecules.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can run the simulation as usual and extract the trajectories.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"adata = [:pos]\nnsteps = 1000 # corresponds to 100s\nadf, = run!(model, microbe_step!, nsteps; adata)\n\ntraj = vectorize_adf_measurement(adf, :pos)\nx = first.(traj)'\ny = last.(traj)'","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Comparing the trajectories for the two bacterial species we witness a chemotactic race (Brumley in blue, BrownBerg in orange).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Chemotactic race in a linear gradient)","category":"page"}]
}
