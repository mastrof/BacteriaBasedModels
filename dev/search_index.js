var documenterSearchIndex = {"docs":
[{"location":"#BacteriaBasedModels.jl","page":"Home","title":"BacteriaBasedModels.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Agent-based modelling of bacterial motility and chemotaxis in Julia.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Built on Agents.jl\nSimulate bacterial motility in 1, 2 and 3 dimensions with customizable motile patterns.\nSimulate chemotaxis with different tunable models (currently implemented Brown-Berg, Brumley).\nEvaluate quantity of interest (mean-squared displacement, autocorrelation functions...).","category":"page"},{"location":"#Next-steps","page":"Home","title":"Next steps","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Integrate differential equations (concentration fields, flow fields) via DifferentialEquations.jl in parallel with agent stepping.\nImplement more motile/search strategies (e.g. chemokinesis, infotaxis)\nExtend the set of core functionalities (e.g. encounters, interactions)\nImplement complex environments (obstacles, pores)\nInclude models for solid bacteria with arbitrary shapes","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Ready-to-run scripts for the functionalities introduced here can be found in the examples directory of the repo.","category":"page"},{"location":"tutorial/#Creating-a-bacterium","page":"Tutorial","title":"Creating a bacterium","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Bacteria are represented by custom types, that must be subtypes of the AbstractAgent type implemented by Agents.jl.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"AbstractMicrobe","category":"page"},{"location":"tutorial/#BacteriaBasedModels.AbstractMicrobe","page":"Tutorial","title":"BacteriaBasedModels.AbstractMicrobe","text":"AbstractMicrobe{D} <: AbstractAgent where {D<:Integer}\nYourMicrobeType{D} <: AbstractMicrobe{D}\n\nAll microbe types in BacteriaBasedModels.jl simulations must be instances of user-defined types that are subtypes of AbstractMicrobe. The parameter D defines the dimensionality of the space in which the microbe type lives (1, 2 and 3 are currently supported).\n\nAll microbe types should have the following fields: - id::Int → id of the microbe - pos::NTuple{D,Float64} → position of the microbe - vel::NTuple{D,Float64} → velocity of the microbe - motility → motile pattern of the microbe - turn_rate::Float64 → average reorientation rate of the microbe - rotational_diffusivity::Float64 → rotational diffusion coefficient\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"By default, BacteriaBasedModels provides a basic Microbe type, that is usually sufficient for the simplest types of simulations.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Microbe","category":"page"},{"location":"tutorial/#BacteriaBasedModels.Microbe","page":"Tutorial","title":"BacteriaBasedModels.Microbe","text":"Microbe{D} <: AbstractMicrobe{D}\n\nBasic microbe type for simple simulations.\n\nDefault parameters:\n\nid::Int → identifier used internally by Agents.jl\npos::NTuple{D,Float64} = ntuple(zero,D) → position\nmotility = RunTumble() → motile pattern\nvel::NTuple{D,Float64} = rand_vel(D) .* rand(motility.speed) → velocity vector\nturn_rate::Float64 = 1.0 → frequency of reorientations\nstate::Float64 → generic variable for a scalar internal state\nrotational_diffusivity::Float64 = 0.0 → rotational diffusion coefficient\nradius::Float64 = 0.0 → equivalent spherical radius of the microbe\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to create a Microbe living in a one-dimensional space we can just call","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Microbe{1}(id=0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It is required to pass a value to the id argument (this behavior might change in the future). All the other parameters will be given default values (as described in the type docstring) if not assigned explicitly.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly, for bacteria living in two or three dimensions we can use","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Microbe{2}(id=0)\nMicrobe{3}(id=0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Custom parameters can be set via kwargs:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Microbe{3}(\n    id = 0,\n    pos = (300.0, 0.0, 0.0),\n    motility = RunTumble(speed = Normal(40.0, 4.0)),\n    vel = rand_vel(3) .* 40.0,\n    turn_rate = 1.5,\n    state = 0.0,\n    rotational_diffusivity = 0.035,\n    radius = 0.5\n)","category":"page"},{"location":"tutorial/#Creating-a-model","page":"Tutorial","title":"Creating a model","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BacteriaBasedModel provides a fast way to initialise an AgentBasedModel (from Agents.jl) via the initialise_model function, using a typical procedure. If higher levels of customization are needed, the model will need to be created by hand.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"initialise_model","category":"page"},{"location":"tutorial/#BacteriaBasedModels.initialise_model","page":"Tutorial","title":"BacteriaBasedModels.initialise_model","text":"initialise_model(;\n    microbes,\n    timestep,\n    extent, spacing = extent/20, periodic = true,\n    random_positions = true,\n    model_properties = Dict(),\n    diffeq = false, ode_integrator = dummy_integrator\n)\n\nInitialise an AgentBasedModel from population microbes. Requires the integration timestep and the extent of the simulation box.\n\nWhen random_positions = true the positions assigned to microbes are ignored and new ones, extracted randomly in the simulation box, are assigned; if random_positions = false the original positions in microbes are kept.\n\nAny extra property can be assigned to the model via the model_properties dictionary.\n\nSet diffeq = true and provide an ode_integrator (e.g. through the initialise_ode function) to integrate a differential equation in parallel to microbe stepping.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now generate a population of microbes and, after choosing an integration timestep and a domain size, we initialise our model, placing the microbes at random locations in the domain.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"microbes = [Microbe{3}(id=i) for i in 1:10]\ntimestep = 0.1\nextent = 100.0\nmodel = initialise_model(;\n    microbes = microbes,\n    timestep = timestep,\n    extent = extent\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"AgentBasedModel with 10 agents of type Microbe\n space: periodic continuous space with (100.0, 100.0, 100.0) extent and spacing=5.0\n scheduler: fastest\n properties: timestep","category":"page"},{"location":"tutorial/#Random-walks","page":"Tutorial","title":"Random walks","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we can already generate random walks. The setup follows previous sections.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"dt = 0.1\nL = 100.0\nnmicrobes = 8\nmicrobes = [Microbe{1}(id=i, pos=(L/2,)) for i in 1:nmicrobes]\n\nmodel = initialise_model(;\n    microbes = microbes,\n    timestep = dt,\n    extent = L, periodic = false,\n    random_positions = false\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we need to define the adata variable to choose what observables we want to track, throughout the simulation, for each agent in the system. In our case, only the position field","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"adata = [:pos]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we can run the simulation; the microbe_step! function will take care of the stepping and reorientations:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"nsteps = 1000\nadf, = run!(model, microbe_step!, nsteps; adata)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"x = vectorize_adf_measurement(adf, :pos) .|> first\nplot(\n    (0:nsteps).*dt, x',\n    legend = false,\n    xlab = \"time\",\n    ylab = \"position\"\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: One-dimensional random walks of 8 microbes starting from same position)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly for a two-dimensional random walk, using run-reverse-flick motility and non-zero rotational diffusion:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"dt = 0.1\nL = 100.0\nnmicrobes = 1\nmicrobes = [\n    Microbe{2}(\n        id=i, pos=(L/2,L/2),\n        motility=RunReverseFlick(),\n        rotational_diffusivity = 0.02,\n        ) for i in 1:nmicrobes\n]\n\nmodel = initialise_model(;\n    microbes = microbes,\n    timestep = dt,\n    extent = extent, periodic = false,\n    random_positions = false,\n)\n\nnsteps = 500\nadata = [:pos]\nadf, = run!(model, microbe_step!, nsteps; adata)\n\ntraj = vectorize_adf_measurement(adf, :pos)\nx = first.(traj)\ny = last.(traj)\nplot(\n    x', y', line_z = (0:nsteps).*dt,\n    legend=false,\n    xlab = \"x\", ylab = \"y\",\n    colorbar = true, colorbar_title = \"time\"\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Two-dimensional random walk using run-reverse-flick motility)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Microbes with different motile patterns can also be combined in the same simulation, without extra complications or computational costs:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"n = 3\nmicrobes_runtumble = [Microbe{2}(id=i, motility=RunTumble()) for i in 1:n]\nmicrobes_runrev = [Microbe{2}(id=n+i, motility=RunReverse()) for i in 1:n]\nmicrobes_runrevflick = [Microbe{2}(id=2n+1, motility=RunReverseFlick()) for i in 1:n]\nmicrobes = vcat(\n    microbes_runtumble, microbes_runrev, microbes_runrevflick\n)","category":"page"},{"location":"tutorial/#Velocity-autocorrelation-functions","page":"Tutorial","title":"Velocity autocorrelation functions","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It's important to check that our microbes are behaving as expected. A way to do so is running a simulation with different motile patterns, and compare their velocity autocorrelation functions to theoretical expectations (Taktikos et al. 2013 PLoS ONE).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First, let's set our parameters","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"U = 30.0 # μm/s\nτ_run = 1.0 # s\nω = 1 / τ_run # 1/s\nΔt = 0.01 # s\nL = 1e4 # μm","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"then we can generate three distinct microbe populations, differing only in their motility, merge them all into a single population and initialise our model","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"n = 200\nmicrobes_runtumble = [\n    Microbe{3}(id=i,\n        turn_rate=ω, vel=rand_vel(3).*U,\n        motility=RunTumble(speed=Degenerate(U))\n    )\n    for i in 1:n\n]\nmicrobes_runrev = [\n    Microbe{3}(id=n+i,\n        turn_rate=ω, vel=rand_vel(3).*U,\n        motility=RunReverse(speed=Degenerate(U))\n    )\n    for i in 1:n\n]\nmicrobes_runrevflick = [\n    Microbe{3}(id=2n+i,\n        turn_rate=ω, vel=rand_vel(3).*U,\n        motility=RunReverseFlick(speed=Degenerate(U))\n    )\n    for i in 1:n\n]\n\nmicrobes = vcat(\n    microbes_runtumble, microbes_runrev, microbes_runrevflick\n)\n\nmodel = initialise_model(;\n    microbes = microbes,\n    timestep = Δt,\n    extent = L, periodic = true\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To evaluate the velocity autocorrelation functions, we only need to store the :vel field of the microbes during the simulation. To get a good statistics we need simulation times that are sufficiently longer than the average run length τ_run.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"nsteps = round(Int, 100τ_run / Δt)\nadata = [:pos, :vel]\nadf, = run!(model, microbe_step!, nsteps; adata)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now separate the three subpopulations by their indices (more generally we could also directly filter by the motility type) and evaluate their velocity autocorrelation functions using the built-in autocorrelation function","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"adf_runtumble = filter(:id => id -> 1≤id≤n, adf; view=true)\nadf_runrev = filter(:id => id -> n+1≤id≤2n, adf; view=true)\nadf_runrevflick = filter(:id => id -> 2n+1≤id≤3n, adf; view=true)\nadfs = [adf_runtumble, adf_runrev, adf_runrevflick]\n\nΦ = hcat([autocorrelation(a,:vel) for a in adfs]...)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The theoretical values are given by Taktikos et al. 2013 PLoS ONE","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"t = range(0, (nsteps-1)*Δt; step=Δt)\nϕ = hcat([\n    exp.(-t ./ τ_run),\n    exp.(-t ./ (τ_run / 2)),\n    (1 .- t ./ (2τ_run)) .* exp.(-t ./ τ_run),\n]...)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A comparison shows a great agreement between simulation and theory.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(\n    xlims=(0,6τ_run), ylims=(-0.1, 1.05),\n    xlab=\"Δt / τ\",\n    ylab=\"velocity autocorrelation\",\n)\nplot!(t, ϕ, lw=2, lc=[1 2 3],\n    label=[\"Run-Tumble\" \"Run-Reverse\" \"Run-Reverse-Flick\"])\nscatter!(t[1:10:end], Φ[1:10:end,:] ./ U^2, m=:x, mc=[1 2 3],\n    label=false)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Comparison between numerical and theoretical velocity autocorrelation functions for bacteria with different motile patterns)","category":"page"},{"location":"tutorial/#Mean-squared-displacement","page":"Tutorial","title":"Mean-squared displacement","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It's also easy to evaluate the mean-squared displacement (MSD) of our microbes during a simulation. We will now run simulations of run-tumble bacteria using different reorientation distributions (parameterized by the average reorientation angle θ), and compare the MSD as a function of θ to theoretical expectations using the well-known diffusivity formula by Berg, D = U²τ/3α, where the persistence factor α=1-cosθ.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We will setup our systems as usual and then run each simulation independently","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"θs = [π/6, π/4, π/3, π/2, π]\n\nU = 30.0 # μm/s \nτ_run = 1.0 # s \nω = 1 / τ_run\n\nnmicrobes = 100\nmicrobes = [\n    [\n        Microbe{3}(\n            id = n, turn_rate = ω,\n            motility = RunTumble(speed=Degenerate(U), yaw=Degenerate(θ))\n        ) for n in 1:nmicrobes \n    ] for θ in θs\n]\n\ndt = 0.05 # s \nL = 500.0 # μm\nmodels = [\n    initialise_model(;\n        microbes = microbes[i],\n        timestep = dt, extent = L\n    ) for i in eachindex(microbes)\n]\n\nnsteps = round(Int, 100τ_run / dt)\nadata = [:pos]\nadfs = [run!(model, microbe_step!, nsteps; adata)[1] for model in models]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now evaluate the MSD for each population using the msd function; since the simulations were performed in a periodic domain, we will need to specify the size of the domain as a keyword argument","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"MSD = msd.(adfs; L=L)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now slice our experimental data and plot the results.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ts = (1:nsteps).*dt\n\nlogslice = [1,2,5,10,25,50,100,250,500,1000]\nplot(\n    xlab = \"Δt (s)\",\n    ylab = \"MSD (μm²/s)\",\n    legend = :bottomright, legendtitle = \"1-cosθ\",\n    scale = :log10\n)\nscatter!(ts[logslice], hcat(MSD...)[logslice,:],\n    m=:x, ms=6, msw=2, lab=false)\nfor i in eachindex(θs)\n    α = 1 - cos(θs[i])\n    τ = τ_run / α\n    D = U^2*τ / 3\n    dr² = @. 2*U^2*τ^2 * (ts/τ - 1 + exp(-ts/τ))\n    plot!(ts, dr², lab=round(α,digits=2), lc=i, lw=2)\nend # for\nplot!()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Mean-squared displacement of run-tumble bacteria with different reorientation distributions)","category":"page"}]
}
